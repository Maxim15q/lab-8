import cv2
import numpy as np

# Define the dictionary and marker size
dictionary = cv2.aruco.Dictionary_get(cv2.aruco.DICT_6X6_250)
marker_size = 100

# Define the parameters for the marker detection
parameters = cv2.aruco.DetectorParameters_create()

# Load the camera
cap = cv2.VideoCapture(0)

# Load the fly image and resize it
fly = cv2.imread('fly64.png')
fly = cv2.resize(fly, (marker_size, marker_size))

while True:
    # Read a frame from the camera
    ret, frame = cap.read()

    # Detect the markers in the frame
    corners, ids, rejected = cv2.aruco.detectMarkers(frame, dictionary, parameters=parameters)

    # If a marker is detected, draw it on the frame and overlay the fly image on it
    if ids is not None:
        # Split the marker into two halves
        half_width = int(corners[0][0][1][0] - corners[0][0][0][0]) // 2
        left_half = np.array([[[corners[0][0][0][0], corners[0][0][0][1]],
                               [corners[0][0][0][0] + half_width, corners[0][0][0][1]],
                               [corners[0][0][1][0] - half_width, corners[0][0][1][1]],
                               [corners[0][0][1][0], corners[0][0][1][1]]]], dtype=np.float32)
        right_half = np.array([[[corners[0][0][1][0] - half_width, corners[0][0][1][1]],
                                [corners[0][0][1][0], corners[0][0][1][1]],
                                [corners[0][0][2][0], corners[0][0][2][1]],
                                [corners[0][0][2][0] - half_width, corners[0][0][2][1]]]], dtype=np.float32)

        # Draw the left half of the marker on the frame
        cv2.aruco.drawDetectedMarkers(frame, left_half, ids)

        # Get the position and orientation of the left half of the marker
        rvecs_left, tvecs_left, _ = cv2.aruco.estimatePoseSingleMarkers(left_half, marker_size, cameraMatrix, distCoeffs)

        # Draw the axis for the left half of the marker
        cv2.aruco.drawAxis(frame, cameraMatrix, distCoeffs, rvecs_left, tvecs_left, marker_size)

        # Draw the right half of the marker on the frame
        cv2.aruco.drawDetectedMarkers(frame, right_half, ids)

        # Get the position and orientation of the right half of the marker
        rvecs_right, tvecs_right, _ = cv2.aruco.estimatePoseSingleMarkers(right_half, marker_size, cameraMatrix, distCoeffs)

        # Draw the axis for the right half of the marker
        cv2.aruco.drawAxis(frame, cameraMatrix, distCoeffs, rvecs_right, tvecs_right, marker_size)

        # Calculate the center of the marker
        center = ((corners[0][0][0][0] + corners[0][0][2][0]) // 2, (corners[0][0][0][1]

        # Overlay the fly image on the marker
        frame_roi = frame[center[1]-marker_size//2:center[1]+marker_size//2, center[0]-marker_size//2:center[0]+marker_size//2]
        fly_gray = cv2.cvtColor(fly, cv2.COLOR_BGR2GRAY)
        _, fly_mask = cv2.threshold(fly_gray, 1, 255, cv2.THRESH_BINARY_INV)
        fly_mask = cv2.cvtColor(fly_mask, cv2.COLOR_GRAY2BGR)
        fly_masked = cv2.bitwise_and(fly, fly_mask)
        frame_masked = cv2.bitwise_and(frame_roi, cv2.bitwise_not(fly_mask))
        frame[center[1]-marker_size//2:center[1]+marker_size//2, center[0]-marker_size//2:center[0]+marker_size//2] = cv2.add(frame_masked, fly_masked)

    # Display the resulting frame
    cv2.imshow('frame', frame)

    # Quit the program if 'q' is pressed
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the camera and close all windows
cap.release()
cv2.destroyAllWindows()
